#labels Phase-Design
In software development, it is of utmost importance that the developer understands the *software development process or life cycle*. This understanding can be developed by studying various models of software development and then deciding on the one that best meets the criteria laid out by the developer. 

In order to select a model that we would be following for our software development we studied the *waterfall model* and the *iterative development model*. Having discussed and deliberated on the model to be used, we finally zeroed in on the waterfall model since we feel that this being our first big project we should do things in a proper *sequential manner* and understand each step properly. 

= Introduction =

Any software development process can be divided into 3 broad categories:

  *Planning - This requires understanding of the domain. For this purpose one needs to interact with domain experts, users of the system and get a clear indication of the shortfalls of the current system. Based on this understanding one needs to compile a list of requirements in the software that would improve the system. Also the scope of the software should be clearly defined in order to avoid complications
 
  *Implementation,testing and documenting - Keeping the requirements in mind, the actual implementation starts. In the implementation and testing phase developers are required to work on the defects that are observed in the software and improve on them. 
 
  *Deployment and maintenance - The final step where the software is deployed into use. This step is crucial since this is where the end user gets access to the software and works on it. It is important that the user should not have much difficulty in getting used to the software. 

= Waterfall Model=

We would be working on the final model as stated by Winston W.Royce.

The initial waterfall model involves a *finish-to-start* dependency structure i.e. one should move to the next phase of development only if the previous phase has been completed. As mentioned earlier it is sequential in nature. 

It follows the steps in order:

1. Understanding Domain and finalizing Requirement Specifications
2. Designing the structure for the software. First a broad overview and then the finer detailed structure.
3. Programming the software
4. Testing the software and receiving the feedback, based on which the debugging exercise would take place
5. Deployment and maintenance of software

However since we are using the modified Waterfall model that states that feedback could at times lead from testing to design as there might be flaws in design that are uncovered based on testing of software and from design back to requirements specification because certain requirements might be presenting a difficulty in the design structure.

So it would be slightly flexible in nature. 




